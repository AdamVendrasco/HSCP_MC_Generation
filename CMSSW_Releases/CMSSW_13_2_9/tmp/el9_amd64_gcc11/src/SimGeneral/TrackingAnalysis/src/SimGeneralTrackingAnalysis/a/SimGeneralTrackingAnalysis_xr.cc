// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME tmpdIel9_amd64_gcc11dIsrcdISimGeneraldITrackingAnalysisdIsrcdISimGeneralTrackingAnalysisdIadISimGeneralTrackingAnalysis_xr
#define R__NO_DEPRECATION

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

// Header files passed as explicit arguments
#include "src/SimGeneral/TrackingAnalysis/src/classes.h"

// Header files passed via #pragma extra_include

// The generated code does not explicitly qualify STL entities
namespace std {} using namespace std;

namespace ROOT {
   static TClass *pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR_Dictionary();
   static void pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR_TClassManip(TClass*);
   static void *new_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p = nullptr);
   static void *newArray_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(Long_t size, void *p);
   static void delete_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p);
   static void deleteArray_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p);
   static void destruct_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >*)
   {
      pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >", "string", 211,
                  typeid(pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >) );
      instance.SetNew(&new_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR);
      instance.SetNewArray(&newArray_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR);
      instance.SetDelete(&delete_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR);
      instance.SetDestructor(&destruct_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR);

      ::ROOT::AddClassAlternate("pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >","pair<TrackingParticleRef,TrackPSimHitRef>");

      ::ROOT::AddClassAlternate("pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >","std::pair<edm::Ref<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle, edm::refhelper::FindUsingAdvance<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle> >, edm::Ref<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit, edm::refhelper::FindUsingAdvance<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >*)nullptr)->GetClass();
      pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR_TClassManip(TClass* theClass){
      theClass->CreateAttributeMap();
      TDictAttributeMap* attrMap( theClass->GetAttributeMap() );
      attrMap->AddProperty("persistent","true");
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_Dictionary();
   static void pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p = nullptr);
   static void *newArray_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p);
   static void deleteArray_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p);
   static void destruct_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)
   {
      pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >", "string", 211,
                  typeid(pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >) );
      instance.SetNew(&new_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetDelete(&delete_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);

      ::ROOT::AddClassAlternate("pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >","std::pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>, Phase2TrackerDigi, edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >, edm::Ptr<TrackingParticle> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)nullptr)->GetClass();
      pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_Dictionary();
   static void pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p = nullptr);
   static void *newArray_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)
   {
      pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >", "string", 211,
                  typeid(pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >) );
      instance.SetNew(&new_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);

      ::ROOT::AddClassAlternate("pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >","pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,allocator<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > >");

      ::ROOT::AddClassAlternate("pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >","std::pair<edm::Ptr<TrackingParticle>, std::vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>, Phase2TrackerDigi, edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >, std::allocator<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>, Phase2TrackerDigi, edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)nullptr)->GetClass();
      pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_Dictionary();
   static void pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p = nullptr);
   static void *newArray_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p);
   static void deleteArray_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p);
   static void destruct_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)
   {
      pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >", "string", 211,
                  typeid(pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >) );
      instance.SetNew(&new_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetDelete(&delete_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR);

      ::ROOT::AddClassAlternate("pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >","std::pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>, Phase2TrackerDigi, edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > const, edm::Ptr<TrackingParticle> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)nullptr)->GetClass();
      pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_Dictionary();
   static void pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p = nullptr);
   static void *newArray_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)
   {
      pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >", "string", 211,
                  typeid(pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >) );
      instance.SetNew(&new_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR);

      ::ROOT::AddClassAlternate("pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >","pair<const edm::Ptr<TrackingParticle>,std::vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,std::allocator<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > >");

      ::ROOT::AddClassAlternate("pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >","std::pair<edm::Ptr<TrackingParticle> const, std::vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>, Phase2TrackerDigi, edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >, std::allocator<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>, Phase2TrackerDigi, edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)nullptr)->GetClass();
      pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p = nullptr);
   static void *newArray_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >*)
   {
      ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >", ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 24,
                  typeid(::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR);

      ::ROOT::AddClassAlternate("edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >","edm::Wrapper<std::vector<std::pair<TrackingParticleRef,TrackPSimHitRef> > >");

      ::ROOT::AddClassAlternate("edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >","edm::Wrapper<std::vector<std::pair<edm::Ref<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle, edm::refhelper::FindUsingAdvance<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle> >, edm::Ref<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit, edm::refhelper::FindUsingAdvance<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit> > >, std::allocator<std::pair<edm::Ref<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle, edm::refhelper::FindUsingAdvance<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle> >, edm::Ref<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit, edm::refhelper::FindUsingAdvance<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit> > > > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >*)nullptr)->GetClass();
      edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > : new pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >;
   }
   static void *newArray_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >[nElements] : new pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p) {
      delete ((pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >*)p);
   }
   static void deleteArray_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p) {
      delete [] ((pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >*)p);
   }
   static void destruct_pairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgR(void *p) {
      typedef pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> > : new pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >;
   }
   static void *newArray_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >[nElements] : new pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      delete ((pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)p);
   }
   static void deleteArray_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      delete [] ((pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)p);
   }
   static void destruct_pairlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      typedef pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > : new pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >;
   }
   static void *newArray_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >[nElements] : new pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)p);
   }
   static void deleteArray_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)p);
   }
   static void destruct_pairlEedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      typedef pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> > : new pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >;
   }
   static void *newArray_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >[nElements] : new pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      delete ((pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)p);
   }
   static void deleteArray_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      delete [] ((pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >*)p);
   }
   static void destruct_pairlEconstsPedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRcOedmcLcLPtrlETrackingParticlegRsPgR(void *p) {
      typedef pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > >,edm::Ptr<TrackingParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > : new pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >;
   }
   static void *newArray_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >[nElements] : new pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)p);
   }
   static void deleteArray_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >*)p);
   }
   static void destruct_pairlEconstsPedmcLcLPtrlETrackingParticlegRcOvectorlEedmcLcLPtrlETTTracklEedmcLcLReflEedmcLcLDetSetVectorlEPhase2TrackerDigigRcOPhase2TrackerDigicOedmcLcLrefhelpercLcLFindForDetSetVectorlEPhase2TrackerDigigRsPgRsPgRsPgRsPgRsPgR(void *p) {
      typedef pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const edm::Ptr<TrackingParticle>,vector<edm::Ptr<TTTrack<edm::Ref<edm::DetSetVector<Phase2TrackerDigi>,Phase2TrackerDigi,edm::refhelper::FindForDetSetVector<Phase2TrackerDigi> > > > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > > : new ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >[nElements] : new ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >

namespace ROOT {
   static TClass *vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR_Dictionary();
   static void vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p = nullptr);
   static void *newArray_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p);
   static void destruct_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >*)
   {
      vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >", -2, "vector", 389,
                  typeid(vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >) );
      instance.SetNew(&new_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >()));

      ::ROOT::AddClassAlternate("vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >","std::vector<std::pair<edm::Ref<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle, edm::refhelper::FindUsingAdvance<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle> >, edm::Ref<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit, edm::refhelper::FindUsingAdvance<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit> > >, std::allocator<std::pair<edm::Ref<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle, edm::refhelper::FindUsingAdvance<std::vector<TrackingParticle, std::allocator<TrackingParticle> >, TrackingParticle> >, edm::Ref<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit, edm::refhelper::FindUsingAdvance<std::vector<PSimHit, std::allocator<PSimHit> >, PSimHit> > > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >*)nullptr)->GetClass();
      vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR_TClassManip(TClass* theClass){
      theClass->CreateAttributeMap();
      TDictAttributeMap* attrMap( theClass->GetAttributeMap() );
      attrMap->AddProperty("persistent","true");
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > : new vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >;
   }
   static void *newArray_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >[nElements] : new vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p) {
      delete ((vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >*)p);
   }
   static void deleteArray_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p) {
      delete [] ((vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >*)p);
   }
   static void destruct_vectorlEpairlEedmcLcLReflEvectorlETrackingParticlegRcOTrackingParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlETrackingParticlegRcOTrackingParticlegRsPgRcOedmcLcLReflEvectorlEPSimHitgRcOPSimHitcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEPSimHitgRcOPSimHitgRsPgRsPgRsPgR(void *p) {
      typedef vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > >

namespace {
  void TriggerDictionaryInitialization_SimGeneralTrackingAnalysis_xr_Impl() {
    static const char* headers[] = {
"0",
nullptr
    };
    static const char* includePaths[] = {
"/afs/cern.ch/user/a/avendras/work/CMSSW_Releases/CMSSW_13_2_9/src",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/cms/cmssw/CMSSW_13_2_9/src",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/dd4hep/v01-23x-c3b1b45ccae1e7b50a2059c42b084226/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/pcre/8.43-bd2b09f5d686f0f36e748ce001d315ad/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/bz2lib/1.0.6-24b287d9981341b8441eb85733326b1a/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/cuda/11.8.0-a2db08b624dc4f754031142a3cdb3a9d/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/gsl/2.6-293f1973c8de87040110bce5dc9d71f6/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/hepmc/2.06.10-85bd895bb097aa1637e1468b4ed8f785/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/libuuid/2.34-f7577986509a353c203144983884d697/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/cms/vdt/0.4.3-1bd5e94666d11cc7a665bff91e9bc16c/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/xerces-c/3.1.3-34f18b2d106eeefb6ef989b2cb7004d9/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/xz/5.2.5-a20522e35d8f009dccedabb2d97b20da/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/zlib/1.2.11-a365170a889b785ec23815da2b99d7d1/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/eigen/82dd3710dac619448f50331c1d6a35da673f764a-f9c27fce684e89466e2ef07869cd264d/include/eigen3",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/fmt/8.0.1-89199f97a8c166a965017c69137de0d0/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/hepmc3/3.2.5-9caf29326adf44098bd76d819db17013/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/md5/1.0.0-6bede1cf43db82355b3835c81f384d05/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/OpenBLAS/0.3.15-907ef51178a81a1f518396b18843e943/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/external/tinyxml2/6.2.0-f05bc085db13b8b4b752c87703ff413d/include",
"/cvmfs/cms.cern.ch/el9_amd64_gcc11/lcg/root/6.26.11-2d3ac1bc6499bcdecfb936cdaff61a09/include/",
"/afs/cern.ch/user/a/avendras/work/CMSSW_Releases/CMSSW_13_2_9/",
nullptr
    };
    static const char* fwdDeclCode = R"DICTFWDDCLS(
#line 1 "SimGeneralTrackingAnalysis_xr dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class __attribute__((annotate("$clingAutoload$SimDataFormats/TrackingAnalysis/interface/TrackingParticle.h")))  TrackingParticle;
namespace edm{namespace refhelper{template <typename C, typename T> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/RefTraits.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1TrackTrigger/interface/TTTypes.h")))  FindUsingAdvance;
}}
namespace edm{namespace refhelper{template <typename REFV> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/RefTraits.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1TrackTrigger/interface/TTTypes.h")))  FindRefVectorUsingAdvance;
}}
namespace edm{namespace refhelper{template <typename C, typename T> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/RefTraits.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1TrackTrigger/interface/TTTypes.h")))  FindTrait;
}}
namespace edm{namespace refhelper{template <typename C> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/RefTraits.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1TrackTrigger/interface/TTTypes.h")))  ValueTrait;
}}
class __attribute__((annotate("$clingAutoload$DataFormats/Phase2TrackerDigi/interface/Phase2TrackerDigi.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1TrackTrigger/interface/TTTypes.h")))  Phase2TrackerDigi;
namespace edm{template <class T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/DetSetVector.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1TrackTrigger/interface/TTTypes.h")))  DetSetVector;
}
namespace edm{namespace refhelper{template <typename T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/DetSetVector.h")))  __attribute__((annotate("$clingAutoload$DataFormats/L1TrackTrigger/interface/TTTypes.h")))  FindForDetSetVector;
}}
)DICTFWDDCLS";
    static const char* payloadCode = R"DICTPAYLOAD(
#line 1 "SimGeneralTrackingAnalysis_xr dictionary payload"

#ifndef CMS_DICT_IMPL
  #define CMS_DICT_IMPL 1
#endif
#ifndef _REENTRANT
  #define _REENTRANT 1
#endif
#ifndef GNUSOURCE
  #define GNUSOURCE 1
#endif
#ifndef __STRICT_ANSI__
  #define __STRICT_ANSI__ 1
#endif
#ifndef GNU_GCC
  #define GNU_GCC 1
#endif
#ifndef _GNU_SOURCE
  #define _GNU_SOURCE 1
#endif
#ifndef EIGEN_DONT_PARALLELIZE
  #define EIGEN_DONT_PARALLELIZE 1
#endif
#ifndef TBB_USE_GLIBCXX_VERSION
  #define TBB_USE_GLIBCXX_VERSION 110401
#endif
#ifndef TBB_SUPPRESS_DEPRECATED_MESSAGES
  #define TBB_SUPPRESS_DEPRECATED_MESSAGES 1
#endif
#ifndef TBB_PREVIEW_RESUMABLE_TASKS
  #define TBB_PREVIEW_RESUMABLE_TASKS 1
#endif
#ifndef TBB_PREVIEW_TASK_GROUP_EXTENSIONS
  #define TBB_PREVIEW_TASK_GROUP_EXTENSIONS 1
#endif
#ifndef BOOST_SPIRIT_THREADSAFE
  #define BOOST_SPIRIT_THREADSAFE 1
#endif
#ifndef PHOENIX_THREADSAFE
  #define PHOENIX_THREADSAFE 1
#endif
#ifndef BOOST_MATH_DISABLE_STD_FPCLASSIFY
  #define BOOST_MATH_DISABLE_STD_FPCLASSIFY 1
#endif
#ifndef BOOST_UUID_RANDOM_PROVIDER_FORCE_POSIX
  #define BOOST_UUID_RANDOM_PROVIDER_FORCE_POSIX 1
#endif
#ifndef DD4HEP_USE_GEANT4_UNITS
  #define DD4HEP_USE_GEANT4_UNITS 1
#endif
#ifndef CMSSW_GIT_HASH
  #define CMSSW_GIT_HASH "CMSSW_13_2_9"
#endif
#ifndef PROJECT_NAME
  #define PROJECT_NAME "CMSSW"
#endif
#ifndef PROJECT_VERSION
  #define PROJECT_VERSION "CMSSW_13_2_9"
#endif
#ifndef CMSSW_REFLEX_DICT
  #define CMSSW_REFLEX_DICT 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#include "DataFormats/Common/interface/Wrapper.h"
#include "DataFormats/L1TrackTrigger/interface/TTTypes.h"
#include "SimDataFormats/TrackingAnalysis/interface/TrackingParticle.h"
#include "SimDataFormats/TrackingAnalysis/interface/TrackingParticleFwd.h"
#include "SimDataFormats/TrackingHit/interface/PSimHitContainer.h"

namespace SimGeneral_TrackingAnalysis {
  struct dictionary {
    edm::Ptr<TrackingParticle> TP;
    std::vector<edm::Ptr<TrackingParticle>> V_TP;
    std::pair<TrackingParticleRef, TrackPSimHitRef> dummy13;
    edm::Wrapper<std::pair<TrackingParticleRef, TrackPSimHitRef>> dummy14;
    std::vector<std::pair<TrackingParticleRef, TrackPSimHitRef>> dummy07;
    edm::Wrapper<std::vector<std::pair<TrackingParticleRef, TrackPSimHitRef>>> dummy08;

    std::pair<edm::Ptr<TTTrack<Ref_Phase2TrackerDigi_>>, edm::Ptr<TrackingParticle>> P_TAM_S_TP_PD;
    std::pair<edm::Ptr<TrackingParticle>, std::vector<edm::Ptr<TTTrack<Ref_Phase2TrackerDigi_>>>> P_TAM_TP_S_PD;

    std::map<edm::Ptr<TTTrack<Ref_Phase2TrackerDigi_>>, edm::Ptr<TrackingParticle>> M_TAM_S_TP_PD;
    std::map<edm::Ptr<TrackingParticle>, std::vector<edm::Ptr<TTTrack<Ref_Phase2TrackerDigi_>>>> M_TAM_TP_S_PD;
  };
}  // namespace SimGeneral_TrackingAnalysis

#undef  _BACKWARD_BACKWARD_WARNING_H
)DICTPAYLOAD";
    static const char* classesHeaders[] = {
"edm::Wrapper<std::vector<std::pair<TrackingParticleRef,TrackPSimHitRef> > >", payloadCode, "@",
"edm::Wrapper<vector<pair<edm::Ref<vector<TrackingParticle>,TrackingParticle,edm::refhelper::FindUsingAdvance<vector<TrackingParticle>,TrackingParticle> >,edm::Ref<vector<PSimHit>,PSimHit,edm::refhelper::FindUsingAdvance<vector<PSimHit>,PSimHit> > > > >", payloadCode, "@",
nullptr
};
    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("SimGeneralTrackingAnalysis_xr",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_SimGeneralTrackingAnalysis_xr_Impl, {}, classesHeaders, /*hasCxxModule*/false);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_SimGeneralTrackingAnalysis_xr_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_SimGeneralTrackingAnalysis_xr() {
  TriggerDictionaryInitialization_SimGeneralTrackingAnalysis_xr_Impl();
}
